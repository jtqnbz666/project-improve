// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wzqGame.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "wzqGame.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace wzq {

namespace {

const ::google::protobuf::Descriptor* REQCreateTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQCreateTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKCreateTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKCreateTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQJoinTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQJoinTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKJoinTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKJoinTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateTableStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateTableStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQReadyGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQReadyGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKReadyGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKReadyGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQStartMatch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQStartMatch_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQStartGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQStartGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKStartGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKStartGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKStartMatch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKStartMatch_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyCreateTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyCreateTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyStartGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyStartGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQDownChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQDownChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKDownChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKDownChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQMatch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQMatch_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKMatch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKMatch_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyCancelMatch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyCancelMatch_reflection_ = NULL;
const ::google::protobuf::Descriptor* WinPosition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WinPosition_reflection_ = NULL;
const ::google::protobuf::Descriptor* WinPosition_Row_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WinPosition_Row_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameOver_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameOver_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyLocalGameStart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyLocalGameStart_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQRegretChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQRegretChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKRegretChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKRegretChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQAgreeRegretChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQAgreeRegretChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKAgreeRegretChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKAgreeRegretChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* REQDisAgreeRegretChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  REQDisAgreeRegretChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKDisAgreeRegretChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKDisAgreeRegretChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyGiveUp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyGiveUp_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyPeaceChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyPeaceChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyASKPeaceChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyASKPeaceChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyAgreePeaceChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyAgreePeaceChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* NotifyDisagreePeaceChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotifyDisagreePeaceChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKAgreePeaceChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKAgreePeaceChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACKDisagreePeaceChess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACKDisagreePeaceChess_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChessMove_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChessMove_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayingResult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayingResult_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* GameState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ChessColorType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RoomType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_wzqGame_2eproto() {
  protobuf_AddDesc_wzqGame_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "wzqGame.proto");
  GOOGLE_CHECK(file != NULL);
  REQCreateTable_descriptor_ = file->message_type(0);
  static const int REQCreateTable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQCreateTable, userid_),
  };
  REQCreateTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQCreateTable_descriptor_,
      REQCreateTable::default_instance_,
      REQCreateTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQCreateTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQCreateTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQCreateTable));
  ACKCreateTable_descriptor_ = file->message_type(1);
  static const int ACKCreateTable_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKCreateTable, resultcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKCreateTable, tableid_),
  };
  ACKCreateTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKCreateTable_descriptor_,
      ACKCreateTable::default_instance_,
      ACKCreateTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKCreateTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKCreateTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKCreateTable));
  REQJoinTable_descriptor_ = file->message_type(2);
  static const int REQJoinTable_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQJoinTable, userid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQJoinTable, tableid_),
  };
  REQJoinTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQJoinTable_descriptor_,
      REQJoinTable::default_instance_,
      REQJoinTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQJoinTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQJoinTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQJoinTable));
  ACKJoinTable_descriptor_ = file->message_type(3);
  static const int ACKJoinTable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKJoinTable, resultcode_),
  };
  ACKJoinTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKJoinTable_descriptor_,
      ACKJoinTable::default_instance_,
      ACKJoinTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKJoinTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKJoinTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKJoinTable));
  UpdateTableStatus_descriptor_ = file->message_type(4);
  static const int UpdateTableStatus_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateTableStatus, tableid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateTableStatus, players_),
  };
  UpdateTableStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateTableStatus_descriptor_,
      UpdateTableStatus::default_instance_,
      UpdateTableStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateTableStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateTableStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateTableStatus));
  PlayerStatus_descriptor_ = file->message_type(5);
  static const int PlayerStatus_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerStatus, baseinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerStatus, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerStatus, color_),
  };
  PlayerStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerStatus_descriptor_,
      PlayerStatus::default_instance_,
      PlayerStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerStatus));
  REQReadyGame_descriptor_ = file->message_type(6);
  static const int REQReadyGame_offsets_[1] = {
  };
  REQReadyGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQReadyGame_descriptor_,
      REQReadyGame::default_instance_,
      REQReadyGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQReadyGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQReadyGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQReadyGame));
  ACKReadyGame_descriptor_ = file->message_type(7);
  static const int ACKReadyGame_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKReadyGame, resultcode_),
  };
  ACKReadyGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKReadyGame_descriptor_,
      ACKReadyGame::default_instance_,
      ACKReadyGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKReadyGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKReadyGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKReadyGame));
  REQStartMatch_descriptor_ = file->message_type(8);
  static const int REQStartMatch_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQStartMatch, userid_),
  };
  REQStartMatch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQStartMatch_descriptor_,
      REQStartMatch::default_instance_,
      REQStartMatch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQStartMatch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQStartMatch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQStartMatch));
  REQStartGame_descriptor_ = file->message_type(9);
  static const int REQStartGame_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQStartGame, userid_),
  };
  REQStartGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQStartGame_descriptor_,
      REQStartGame::default_instance_,
      REQStartGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQStartGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQStartGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQStartGame));
  ACKStartGame_descriptor_ = file->message_type(10);
  static const int ACKStartGame_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKStartGame, resultcode_),
  };
  ACKStartGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKStartGame_descriptor_,
      ACKStartGame::default_instance_,
      ACKStartGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKStartGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKStartGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKStartGame));
  ACKStartMatch_descriptor_ = file->message_type(11);
  static const int ACKStartMatch_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKStartMatch, resultcode_),
  };
  ACKStartMatch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKStartMatch_descriptor_,
      ACKStartMatch::default_instance_,
      ACKStartMatch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKStartMatch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKStartMatch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKStartMatch));
  NotifyCreateTable_descriptor_ = file->message_type(12);
  static const int NotifyCreateTable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCreateTable, players_),
  };
  NotifyCreateTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyCreateTable_descriptor_,
      NotifyCreateTable::default_instance_,
      NotifyCreateTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCreateTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCreateTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyCreateTable));
  NotifyStartGame_descriptor_ = file->message_type(13);
  static const int NotifyStartGame_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyStartGame, userid1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyStartGame, userid2_),
  };
  NotifyStartGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyStartGame_descriptor_,
      NotifyStartGame::default_instance_,
      NotifyStartGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyStartGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyStartGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyStartGame));
  REQDownChess_descriptor_ = file->message_type(14);
  static const int REQDownChess_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDownChess, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDownChess, posx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDownChess, posy_),
  };
  REQDownChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQDownChess_descriptor_,
      REQDownChess::default_instance_,
      REQDownChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDownChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDownChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQDownChess));
  ACKDownChess_descriptor_ = file->message_type(15);
  static const int ACKDownChess_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDownChess, posx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDownChess, posy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDownChess, color_),
  };
  ACKDownChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKDownChess_descriptor_,
      ACKDownChess::default_instance_,
      ACKDownChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDownChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDownChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKDownChess));
  REQMatch_descriptor_ = file->message_type(16);
  static const int REQMatch_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQMatch, userid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQMatch, roomtype_),
  };
  REQMatch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQMatch_descriptor_,
      REQMatch::default_instance_,
      REQMatch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQMatch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQMatch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQMatch));
  ACKMatch_descriptor_ = file->message_type(17);
  static const int ACKMatch_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKMatch, resultcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKMatch, enemyuserinfo_),
  };
  ACKMatch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKMatch_descriptor_,
      ACKMatch::default_instance_,
      ACKMatch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKMatch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKMatch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKMatch));
  NotifyCancelMatch_descriptor_ = file->message_type(18);
  static const int NotifyCancelMatch_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCancelMatch, userid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCancelMatch, roomtype_),
  };
  NotifyCancelMatch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyCancelMatch_descriptor_,
      NotifyCancelMatch::default_instance_,
      NotifyCancelMatch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCancelMatch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyCancelMatch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyCancelMatch));
  WinPosition_descriptor_ = file->message_type(19);
  static const int WinPosition_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WinPosition, matrix_),
  };
  WinPosition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WinPosition_descriptor_,
      WinPosition::default_instance_,
      WinPosition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WinPosition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WinPosition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WinPosition));
  WinPosition_Row_descriptor_ = WinPosition_descriptor_->nested_type(0);
  static const int WinPosition_Row_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WinPosition_Row, values_),
  };
  WinPosition_Row_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WinPosition_Row_descriptor_,
      WinPosition_Row::default_instance_,
      WinPosition_Row_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WinPosition_Row, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WinPosition_Row, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WinPosition_Row));
  GameOver_descriptor_ = file->message_type(20);
  static const int GameOver_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameOver, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameOver, winposition_),
  };
  GameOver_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameOver_descriptor_,
      GameOver::default_instance_,
      GameOver_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameOver, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameOver, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameOver));
  NotifyLocalGameStart_descriptor_ = file->message_type(21);
  static const int NotifyLocalGameStart_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyLocalGameStart, chesscolor_),
  };
  NotifyLocalGameStart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyLocalGameStart_descriptor_,
      NotifyLocalGameStart::default_instance_,
      NotifyLocalGameStart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyLocalGameStart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyLocalGameStart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyLocalGameStart));
  REQRegretChess_descriptor_ = file->message_type(22);
  static const int REQRegretChess_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQRegretChess, resultcode_),
  };
  REQRegretChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQRegretChess_descriptor_,
      REQRegretChess::default_instance_,
      REQRegretChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQRegretChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQRegretChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQRegretChess));
  ACKRegretChess_descriptor_ = file->message_type(23);
  static const int ACKRegretChess_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKRegretChess, resultcode_),
  };
  ACKRegretChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKRegretChess_descriptor_,
      ACKRegretChess::default_instance_,
      ACKRegretChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKRegretChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKRegretChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKRegretChess));
  REQAgreeRegretChess_descriptor_ = file->message_type(24);
  static const int REQAgreeRegretChess_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQAgreeRegretChess, resultcode_),
  };
  REQAgreeRegretChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQAgreeRegretChess_descriptor_,
      REQAgreeRegretChess::default_instance_,
      REQAgreeRegretChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQAgreeRegretChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQAgreeRegretChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQAgreeRegretChess));
  ACKAgreeRegretChess_descriptor_ = file->message_type(25);
  static const int ACKAgreeRegretChess_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKAgreeRegretChess, resultcode_),
  };
  ACKAgreeRegretChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKAgreeRegretChess_descriptor_,
      ACKAgreeRegretChess::default_instance_,
      ACKAgreeRegretChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKAgreeRegretChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKAgreeRegretChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKAgreeRegretChess));
  REQDisAgreeRegretChess_descriptor_ = file->message_type(26);
  static const int REQDisAgreeRegretChess_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDisAgreeRegretChess, resultcode_),
  };
  REQDisAgreeRegretChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      REQDisAgreeRegretChess_descriptor_,
      REQDisAgreeRegretChess::default_instance_,
      REQDisAgreeRegretChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDisAgreeRegretChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(REQDisAgreeRegretChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(REQDisAgreeRegretChess));
  ACKDisAgreeRegretChess_descriptor_ = file->message_type(27);
  static const int ACKDisAgreeRegretChess_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDisAgreeRegretChess, resultcode_),
  };
  ACKDisAgreeRegretChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKDisAgreeRegretChess_descriptor_,
      ACKDisAgreeRegretChess::default_instance_,
      ACKDisAgreeRegretChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDisAgreeRegretChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDisAgreeRegretChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKDisAgreeRegretChess));
  NotifyGiveUp_descriptor_ = file->message_type(28);
  static const int NotifyGiveUp_offsets_[1] = {
  };
  NotifyGiveUp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyGiveUp_descriptor_,
      NotifyGiveUp::default_instance_,
      NotifyGiveUp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyGiveUp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyGiveUp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyGiveUp));
  NotifyPeaceChess_descriptor_ = file->message_type(29);
  static const int NotifyPeaceChess_offsets_[1] = {
  };
  NotifyPeaceChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyPeaceChess_descriptor_,
      NotifyPeaceChess::default_instance_,
      NotifyPeaceChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyPeaceChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyPeaceChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyPeaceChess));
  NotifyASKPeaceChess_descriptor_ = file->message_type(30);
  static const int NotifyASKPeaceChess_offsets_[1] = {
  };
  NotifyASKPeaceChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyASKPeaceChess_descriptor_,
      NotifyASKPeaceChess::default_instance_,
      NotifyASKPeaceChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyASKPeaceChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyASKPeaceChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyASKPeaceChess));
  NotifyAgreePeaceChess_descriptor_ = file->message_type(31);
  static const int NotifyAgreePeaceChess_offsets_[1] = {
  };
  NotifyAgreePeaceChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyAgreePeaceChess_descriptor_,
      NotifyAgreePeaceChess::default_instance_,
      NotifyAgreePeaceChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyAgreePeaceChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyAgreePeaceChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyAgreePeaceChess));
  NotifyDisagreePeaceChess_descriptor_ = file->message_type(32);
  static const int NotifyDisagreePeaceChess_offsets_[1] = {
  };
  NotifyDisagreePeaceChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NotifyDisagreePeaceChess_descriptor_,
      NotifyDisagreePeaceChess::default_instance_,
      NotifyDisagreePeaceChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyDisagreePeaceChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyDisagreePeaceChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NotifyDisagreePeaceChess));
  ACKAgreePeaceChess_descriptor_ = file->message_type(33);
  static const int ACKAgreePeaceChess_offsets_[1] = {
  };
  ACKAgreePeaceChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKAgreePeaceChess_descriptor_,
      ACKAgreePeaceChess::default_instance_,
      ACKAgreePeaceChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKAgreePeaceChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKAgreePeaceChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKAgreePeaceChess));
  ACKDisagreePeaceChess_descriptor_ = file->message_type(34);
  static const int ACKDisagreePeaceChess_offsets_[1] = {
  };
  ACKDisagreePeaceChess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACKDisagreePeaceChess_descriptor_,
      ACKDisagreePeaceChess::default_instance_,
      ACKDisagreePeaceChess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDisagreePeaceChess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACKDisagreePeaceChess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACKDisagreePeaceChess));
  ChessMove_descriptor_ = file->message_type(35);
  static const int ChessMove_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChessMove, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChessMove, y_),
  };
  ChessMove_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChessMove_descriptor_,
      ChessMove::default_instance_,
      ChessMove_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChessMove, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChessMove, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChessMove));
  PlayingResult_descriptor_ = file->message_type(36);
  static const int PlayingResult_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, gameresult_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, winuserid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, loseuserid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, moves_),
  };
  PlayingResult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayingResult_descriptor_,
      PlayingResult::default_instance_,
      PlayingResult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayingResult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayingResult));
  GameState_descriptor_ = file->enum_type(0);
  ChessColorType_descriptor_ = file->enum_type(1);
  RoomType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_wzqGame_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQCreateTable_descriptor_, &REQCreateTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKCreateTable_descriptor_, &ACKCreateTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQJoinTable_descriptor_, &REQJoinTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKJoinTable_descriptor_, &ACKJoinTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateTableStatus_descriptor_, &UpdateTableStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerStatus_descriptor_, &PlayerStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQReadyGame_descriptor_, &REQReadyGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKReadyGame_descriptor_, &ACKReadyGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQStartMatch_descriptor_, &REQStartMatch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQStartGame_descriptor_, &REQStartGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKStartGame_descriptor_, &ACKStartGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKStartMatch_descriptor_, &ACKStartMatch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyCreateTable_descriptor_, &NotifyCreateTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyStartGame_descriptor_, &NotifyStartGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQDownChess_descriptor_, &REQDownChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKDownChess_descriptor_, &ACKDownChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQMatch_descriptor_, &REQMatch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKMatch_descriptor_, &ACKMatch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyCancelMatch_descriptor_, &NotifyCancelMatch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WinPosition_descriptor_, &WinPosition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WinPosition_Row_descriptor_, &WinPosition_Row::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameOver_descriptor_, &GameOver::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyLocalGameStart_descriptor_, &NotifyLocalGameStart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQRegretChess_descriptor_, &REQRegretChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKRegretChess_descriptor_, &ACKRegretChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQAgreeRegretChess_descriptor_, &REQAgreeRegretChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKAgreeRegretChess_descriptor_, &ACKAgreeRegretChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    REQDisAgreeRegretChess_descriptor_, &REQDisAgreeRegretChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKDisAgreeRegretChess_descriptor_, &ACKDisAgreeRegretChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyGiveUp_descriptor_, &NotifyGiveUp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyPeaceChess_descriptor_, &NotifyPeaceChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyASKPeaceChess_descriptor_, &NotifyASKPeaceChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyAgreePeaceChess_descriptor_, &NotifyAgreePeaceChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NotifyDisagreePeaceChess_descriptor_, &NotifyDisagreePeaceChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKAgreePeaceChess_descriptor_, &ACKAgreePeaceChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACKDisagreePeaceChess_descriptor_, &ACKDisagreePeaceChess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChessMove_descriptor_, &ChessMove::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayingResult_descriptor_, &PlayingResult::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_wzqGame_2eproto() {
  delete REQCreateTable::default_instance_;
  delete REQCreateTable_reflection_;
  delete ACKCreateTable::default_instance_;
  delete ACKCreateTable_reflection_;
  delete REQJoinTable::default_instance_;
  delete REQJoinTable_reflection_;
  delete ACKJoinTable::default_instance_;
  delete ACKJoinTable_reflection_;
  delete UpdateTableStatus::default_instance_;
  delete UpdateTableStatus_reflection_;
  delete PlayerStatus::default_instance_;
  delete PlayerStatus_reflection_;
  delete REQReadyGame::default_instance_;
  delete REQReadyGame_reflection_;
  delete ACKReadyGame::default_instance_;
  delete ACKReadyGame_reflection_;
  delete REQStartMatch::default_instance_;
  delete REQStartMatch_reflection_;
  delete REQStartGame::default_instance_;
  delete REQStartGame_reflection_;
  delete ACKStartGame::default_instance_;
  delete ACKStartGame_reflection_;
  delete ACKStartMatch::default_instance_;
  delete ACKStartMatch_reflection_;
  delete NotifyCreateTable::default_instance_;
  delete NotifyCreateTable_reflection_;
  delete NotifyStartGame::default_instance_;
  delete NotifyStartGame_reflection_;
  delete REQDownChess::default_instance_;
  delete REQDownChess_reflection_;
  delete ACKDownChess::default_instance_;
  delete ACKDownChess_reflection_;
  delete REQMatch::default_instance_;
  delete REQMatch_reflection_;
  delete ACKMatch::default_instance_;
  delete ACKMatch_reflection_;
  delete NotifyCancelMatch::default_instance_;
  delete NotifyCancelMatch_reflection_;
  delete WinPosition::default_instance_;
  delete WinPosition_reflection_;
  delete WinPosition_Row::default_instance_;
  delete WinPosition_Row_reflection_;
  delete GameOver::default_instance_;
  delete GameOver_reflection_;
  delete NotifyLocalGameStart::default_instance_;
  delete NotifyLocalGameStart_reflection_;
  delete REQRegretChess::default_instance_;
  delete REQRegretChess_reflection_;
  delete ACKRegretChess::default_instance_;
  delete ACKRegretChess_reflection_;
  delete REQAgreeRegretChess::default_instance_;
  delete REQAgreeRegretChess_reflection_;
  delete ACKAgreeRegretChess::default_instance_;
  delete ACKAgreeRegretChess_reflection_;
  delete REQDisAgreeRegretChess::default_instance_;
  delete REQDisAgreeRegretChess_reflection_;
  delete ACKDisAgreeRegretChess::default_instance_;
  delete ACKDisAgreeRegretChess_reflection_;
  delete NotifyGiveUp::default_instance_;
  delete NotifyGiveUp_reflection_;
  delete NotifyPeaceChess::default_instance_;
  delete NotifyPeaceChess_reflection_;
  delete NotifyASKPeaceChess::default_instance_;
  delete NotifyASKPeaceChess_reflection_;
  delete NotifyAgreePeaceChess::default_instance_;
  delete NotifyAgreePeaceChess_reflection_;
  delete NotifyDisagreePeaceChess::default_instance_;
  delete NotifyDisagreePeaceChess_reflection_;
  delete ACKAgreePeaceChess::default_instance_;
  delete ACKAgreePeaceChess_reflection_;
  delete ACKDisagreePeaceChess::default_instance_;
  delete ACKDisagreePeaceChess_reflection_;
  delete ChessMove::default_instance_;
  delete ChessMove_reflection_;
  delete PlayingResult::default_instance_;
  delete PlayingResult_reflection_;
}

void protobuf_AddDesc_wzqGame_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_wzqProtocol_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rwzqGame.proto\022\003wzq\032\021wzqProtocol.proto\""
    " \n\016REQCreateTable\022\016\n\006userID\030\001 \001(\003\"5\n\016ACK"
    "CreateTable\022\022\n\nresultCode\030\001 \001(\005\022\017\n\007table"
    "ID\030\002 \001(\t\"/\n\014REQJoinTable\022\016\n\006userID\030\001 \001(\003"
    "\022\017\n\007tableID\030\002 \001(\t\"\"\n\014ACKJoinTable\022\022\n\nres"
    "ultCode\030\001 \001(\005\"H\n\021UpdateTableStatus\022\017\n\007ta"
    "bleID\030\001 \001(\t\022\"\n\007players\030\002 \003(\0132\021.wzq.Playe"
    "rStatus\"q\n\014PlayerStatus\022\036\n\010baseInfo\030\001 \001("
    "\0132\014.UserRawData\022\035\n\005state\030\002 \001(\0162\016.wzq.Gam"
    "eState\022\"\n\005color\030\003 \001(\0162\023.wzq.ChessColorTy"
    "pe\"\016\n\014REQReadyGame\"\"\n\014ACKReadyGame\022\022\n\nre"
    "sultCode\030\001 \001(\005\"\037\n\rREQStartMatch\022\016\n\006userI"
    "D\030\001 \001(\003\"\036\n\014REQStartGame\022\016\n\006userID\030\001 \001(\003\""
    "\"\n\014ACKStartGame\022\022\n\nresultCode\030\001 \001(\005\"#\n\rA"
    "CKStartMatch\022\022\n\nresultCode\030\001 \001(\005\"$\n\021Noti"
    "fyCreateTable\022\017\n\007players\030\001 \003(\003\"3\n\017Notify"
    "StartGame\022\017\n\007userId1\030\001 \002(\003\022\017\n\007userId2\030\002 "
    "\002(\003\";\n\014REQDownChess\022\017\n\007user_id\030\001 \001(\003\022\014\n\004"
    "posX\030\002 \001(\005\022\014\n\004posY\030\003 \001(\005\"N\n\014ACKDownChess"
    "\022\014\n\004posX\030\001 \001(\005\022\014\n\004posY\030\002 \001(\005\022\"\n\005color\030\003 "
    "\001(\0162\023.wzq.ChessColorType\",\n\010REQMatch\022\016\n\006"
    "userID\030\001 \001(\003\022\020\n\010roomType\030\002 \002(\005\"C\n\010ACKMat"
    "ch\022\022\n\nresultCode\030\001 \001(\005\022#\n\renemyUserInfo\030"
    "\002 \001(\0132\014.UserRawData\"5\n\021NotifyCancelMatch"
    "\022\016\n\006userId\030\001 \001(\003\022\020\n\010roomType\030\002 \001(\005\"J\n\013Wi"
    "nPosition\022$\n\006matrix\030\001 \003(\0132\024.wzq.WinPosit"
    "ion.Row\032\025\n\003Row\022\016\n\006values\030\001 \003(\005\"P\n\010GameOv"
    "er\022\035\n\005state\030\001 \001(\0162\016.wzq.GameState\022%\n\013win"
    "position\030\002 \001(\0132\020.wzq.WinPosition\"\?\n\024Noti"
    "fyLocalGameStart\022\'\n\nchessColor\030\001 \001(\0162\023.w"
    "zq.ChessColorType\"$\n\016REQRegretChess\022\022\n\nr"
    "esultCode\030\001 \001(\005\"$\n\016ACKRegretChess\022\022\n\nres"
    "ultCode\030\001 \001(\005\")\n\023REQAgreeRegretChess\022\022\n\n"
    "resultCode\030\001 \001(\005\")\n\023ACKAgreeRegretChess\022"
    "\022\n\nresultCode\030\001 \001(\005\",\n\026REQDisAgreeRegret"
    "Chess\022\022\n\nresultCode\030\001 \001(\005\",\n\026ACKDisAgree"
    "RegretChess\022\022\n\nresultCode\030\001 \001(\005\"\016\n\014Notif"
    "yGiveUp\"\022\n\020NotifyPeaceChess\"\025\n\023NotifyASK"
    "PeaceChess\"\027\n\025NotifyAgreePeaceChess\"\032\n\030N"
    "otifyDisagreePeaceChess\"\024\n\022ACKAgreePeace"
    "Chess\"\027\n\025ACKDisagreePeaceChess\"!\n\tChessM"
    "ove\022\t\n\001x\030\001 \001(\005\022\t\n\001y\030\002 \001(\005\"\235\001\n\rPlayingRes"
    "ult\022\"\n\ngameresult\030\001 \001(\0162\016.wzq.GameState\022"
    "\021\n\twinuserID\030\002 \001(\003\022\022\n\nloseuserID\030\003 \001(\003\022\""
    "\n\005color\030\004 \001(\0162\023.wzq.ChessColorType\022\035\n\005mo"
    "ves\030\005 \003(\0132\016.wzq.ChessMove*o\n\tGameState\022\016"
    "\n\nGS_UNKNOWN\020\000\022\013\n\007GS_DRAW\020\001\022\n\n\006GS_WIN\020\002\022"
    "\013\n\007GS_LOSE\020\003\022\014\n\010GS_READY\020\004\022\016\n\nGS_UNREADY"
    "\020\005\022\016\n\nGS_PLAYING\020\006*E\n\016ChessColorType\022\021\n\r"
    "Chess_UnKnown\020\000\022\017\n\013Chess_White\020\001\022\017\n\013Ches"
    "s_Black\020\002*\?\n\010RoomType\022\016\n\nRT_PRIMARY\020\001\022\023\n"
    "\017RT_INTERMEDIATE\020\002\022\016\n\nRT_PREMIUM\020\003", 2074);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "wzqGame.proto", &protobuf_RegisterTypes);
  REQCreateTable::default_instance_ = new REQCreateTable();
  ACKCreateTable::default_instance_ = new ACKCreateTable();
  REQJoinTable::default_instance_ = new REQJoinTable();
  ACKJoinTable::default_instance_ = new ACKJoinTable();
  UpdateTableStatus::default_instance_ = new UpdateTableStatus();
  PlayerStatus::default_instance_ = new PlayerStatus();
  REQReadyGame::default_instance_ = new REQReadyGame();
  ACKReadyGame::default_instance_ = new ACKReadyGame();
  REQStartMatch::default_instance_ = new REQStartMatch();
  REQStartGame::default_instance_ = new REQStartGame();
  ACKStartGame::default_instance_ = new ACKStartGame();
  ACKStartMatch::default_instance_ = new ACKStartMatch();
  NotifyCreateTable::default_instance_ = new NotifyCreateTable();
  NotifyStartGame::default_instance_ = new NotifyStartGame();
  REQDownChess::default_instance_ = new REQDownChess();
  ACKDownChess::default_instance_ = new ACKDownChess();
  REQMatch::default_instance_ = new REQMatch();
  ACKMatch::default_instance_ = new ACKMatch();
  NotifyCancelMatch::default_instance_ = new NotifyCancelMatch();
  WinPosition::default_instance_ = new WinPosition();
  WinPosition_Row::default_instance_ = new WinPosition_Row();
  GameOver::default_instance_ = new GameOver();
  NotifyLocalGameStart::default_instance_ = new NotifyLocalGameStart();
  REQRegretChess::default_instance_ = new REQRegretChess();
  ACKRegretChess::default_instance_ = new ACKRegretChess();
  REQAgreeRegretChess::default_instance_ = new REQAgreeRegretChess();
  ACKAgreeRegretChess::default_instance_ = new ACKAgreeRegretChess();
  REQDisAgreeRegretChess::default_instance_ = new REQDisAgreeRegretChess();
  ACKDisAgreeRegretChess::default_instance_ = new ACKDisAgreeRegretChess();
  NotifyGiveUp::default_instance_ = new NotifyGiveUp();
  NotifyPeaceChess::default_instance_ = new NotifyPeaceChess();
  NotifyASKPeaceChess::default_instance_ = new NotifyASKPeaceChess();
  NotifyAgreePeaceChess::default_instance_ = new NotifyAgreePeaceChess();
  NotifyDisagreePeaceChess::default_instance_ = new NotifyDisagreePeaceChess();
  ACKAgreePeaceChess::default_instance_ = new ACKAgreePeaceChess();
  ACKDisagreePeaceChess::default_instance_ = new ACKDisagreePeaceChess();
  ChessMove::default_instance_ = new ChessMove();
  PlayingResult::default_instance_ = new PlayingResult();
  REQCreateTable::default_instance_->InitAsDefaultInstance();
  ACKCreateTable::default_instance_->InitAsDefaultInstance();
  REQJoinTable::default_instance_->InitAsDefaultInstance();
  ACKJoinTable::default_instance_->InitAsDefaultInstance();
  UpdateTableStatus::default_instance_->InitAsDefaultInstance();
  PlayerStatus::default_instance_->InitAsDefaultInstance();
  REQReadyGame::default_instance_->InitAsDefaultInstance();
  ACKReadyGame::default_instance_->InitAsDefaultInstance();
  REQStartMatch::default_instance_->InitAsDefaultInstance();
  REQStartGame::default_instance_->InitAsDefaultInstance();
  ACKStartGame::default_instance_->InitAsDefaultInstance();
  ACKStartMatch::default_instance_->InitAsDefaultInstance();
  NotifyCreateTable::default_instance_->InitAsDefaultInstance();
  NotifyStartGame::default_instance_->InitAsDefaultInstance();
  REQDownChess::default_instance_->InitAsDefaultInstance();
  ACKDownChess::default_instance_->InitAsDefaultInstance();
  REQMatch::default_instance_->InitAsDefaultInstance();
  ACKMatch::default_instance_->InitAsDefaultInstance();
  NotifyCancelMatch::default_instance_->InitAsDefaultInstance();
  WinPosition::default_instance_->InitAsDefaultInstance();
  WinPosition_Row::default_instance_->InitAsDefaultInstance();
  GameOver::default_instance_->InitAsDefaultInstance();
  NotifyLocalGameStart::default_instance_->InitAsDefaultInstance();
  REQRegretChess::default_instance_->InitAsDefaultInstance();
  ACKRegretChess::default_instance_->InitAsDefaultInstance();
  REQAgreeRegretChess::default_instance_->InitAsDefaultInstance();
  ACKAgreeRegretChess::default_instance_->InitAsDefaultInstance();
  REQDisAgreeRegretChess::default_instance_->InitAsDefaultInstance();
  ACKDisAgreeRegretChess::default_instance_->InitAsDefaultInstance();
  NotifyGiveUp::default_instance_->InitAsDefaultInstance();
  NotifyPeaceChess::default_instance_->InitAsDefaultInstance();
  NotifyASKPeaceChess::default_instance_->InitAsDefaultInstance();
  NotifyAgreePeaceChess::default_instance_->InitAsDefaultInstance();
  NotifyDisagreePeaceChess::default_instance_->InitAsDefaultInstance();
  ACKAgreePeaceChess::default_instance_->InitAsDefaultInstance();
  ACKDisagreePeaceChess::default_instance_->InitAsDefaultInstance();
  ChessMove::default_instance_->InitAsDefaultInstance();
  PlayingResult::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_wzqGame_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_wzqGame_2eproto {
  StaticDescriptorInitializer_wzqGame_2eproto() {
    protobuf_AddDesc_wzqGame_2eproto();
  }
} static_descriptor_initializer_wzqGame_2eproto_;
const ::google::protobuf::EnumDescriptor* GameState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameState_descriptor_;
}
bool GameState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ChessColorType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChessColorType_descriptor_;
}
bool ChessColorType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoomType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoomType_descriptor_;
}
bool RoomType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int REQCreateTable::kUserIDFieldNumber;
#endif  // !_MSC_VER

REQCreateTable::REQCreateTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQCreateTable::InitAsDefaultInstance() {
}

REQCreateTable::REQCreateTable(const REQCreateTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQCreateTable::SharedCtor() {
  _cached_size_ = 0;
  userid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQCreateTable::~REQCreateTable() {
  SharedDtor();
}

void REQCreateTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQCreateTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQCreateTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQCreateTable_descriptor_;
}

const REQCreateTable& REQCreateTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQCreateTable* REQCreateTable::default_instance_ = NULL;

REQCreateTable* REQCreateTable::New() const {
  return new REQCreateTable;
}

void REQCreateTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQCreateTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQCreateTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQCreateTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQCreateTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQCreateTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQCreateTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQCreateTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQCreateTable::MergeFrom(const REQCreateTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQCreateTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQCreateTable::CopyFrom(const REQCreateTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQCreateTable::IsInitialized() const {

  return true;
}

void REQCreateTable::Swap(REQCreateTable* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQCreateTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQCreateTable_descriptor_;
  metadata.reflection = REQCreateTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKCreateTable::kResultCodeFieldNumber;
const int ACKCreateTable::kTableIDFieldNumber;
#endif  // !_MSC_VER

ACKCreateTable::ACKCreateTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKCreateTable::InitAsDefaultInstance() {
}

ACKCreateTable::ACKCreateTable(const ACKCreateTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKCreateTable::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  tableid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKCreateTable::~ACKCreateTable() {
  SharedDtor();
}

void ACKCreateTable::SharedDtor() {
  if (tableid_ != &::google::protobuf::internal::kEmptyString) {
    delete tableid_;
  }
  if (this != default_instance_) {
  }
}

void ACKCreateTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKCreateTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKCreateTable_descriptor_;
}

const ACKCreateTable& ACKCreateTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKCreateTable* ACKCreateTable::default_instance_ = NULL;

ACKCreateTable* ACKCreateTable::New() const {
  return new ACKCreateTable;
}

void ACKCreateTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
    if (has_tableid()) {
      if (tableid_ != &::google::protobuf::internal::kEmptyString) {
        tableid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKCreateTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tableID;
        break;
      }

      // optional string tableID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tableID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tableid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->tableid().data(), this->tableid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKCreateTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  // optional string tableID = 2;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tableid().data(), this->tableid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->tableid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKCreateTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  // optional string tableID = 2;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tableid().data(), this->tableid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->tableid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKCreateTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

    // optional string tableID = 2;
    if (has_tableid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tableid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKCreateTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKCreateTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKCreateTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKCreateTable::MergeFrom(const ACKCreateTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
    if (from.has_tableid()) {
      set_tableid(from.tableid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKCreateTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKCreateTable::CopyFrom(const ACKCreateTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKCreateTable::IsInitialized() const {

  return true;
}

void ACKCreateTable::Swap(ACKCreateTable* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(tableid_, other->tableid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKCreateTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKCreateTable_descriptor_;
  metadata.reflection = ACKCreateTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQJoinTable::kUserIDFieldNumber;
const int REQJoinTable::kTableIDFieldNumber;
#endif  // !_MSC_VER

REQJoinTable::REQJoinTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQJoinTable::InitAsDefaultInstance() {
}

REQJoinTable::REQJoinTable(const REQJoinTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQJoinTable::SharedCtor() {
  _cached_size_ = 0;
  userid_ = GOOGLE_LONGLONG(0);
  tableid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQJoinTable::~REQJoinTable() {
  SharedDtor();
}

void REQJoinTable::SharedDtor() {
  if (tableid_ != &::google::protobuf::internal::kEmptyString) {
    delete tableid_;
  }
  if (this != default_instance_) {
  }
}

void REQJoinTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQJoinTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQJoinTable_descriptor_;
}

const REQJoinTable& REQJoinTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQJoinTable* REQJoinTable::default_instance_ = NULL;

REQJoinTable* REQJoinTable::New() const {
  return new REQJoinTable;
}

void REQJoinTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid_ = GOOGLE_LONGLONG(0);
    if (has_tableid()) {
      if (tableid_ != &::google::protobuf::internal::kEmptyString) {
        tableid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQJoinTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tableID;
        break;
      }

      // optional string tableID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tableID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tableid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->tableid().data(), this->tableid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQJoinTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid(), output);
  }

  // optional string tableID = 2;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tableid().data(), this->tableid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->tableid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQJoinTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid(), target);
  }

  // optional string tableID = 2;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tableid().data(), this->tableid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->tableid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQJoinTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid());
    }

    // optional string tableID = 2;
    if (has_tableid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tableid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQJoinTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQJoinTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQJoinTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQJoinTable::MergeFrom(const REQJoinTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_tableid()) {
      set_tableid(from.tableid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQJoinTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQJoinTable::CopyFrom(const REQJoinTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQJoinTable::IsInitialized() const {

  return true;
}

void REQJoinTable::Swap(REQJoinTable* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(tableid_, other->tableid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQJoinTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQJoinTable_descriptor_;
  metadata.reflection = REQJoinTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKJoinTable::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKJoinTable::ACKJoinTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKJoinTable::InitAsDefaultInstance() {
}

ACKJoinTable::ACKJoinTable(const ACKJoinTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKJoinTable::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKJoinTable::~ACKJoinTable() {
  SharedDtor();
}

void ACKJoinTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKJoinTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKJoinTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKJoinTable_descriptor_;
}

const ACKJoinTable& ACKJoinTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKJoinTable* ACKJoinTable::default_instance_ = NULL;

ACKJoinTable* ACKJoinTable::New() const {
  return new ACKJoinTable;
}

void ACKJoinTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKJoinTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKJoinTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKJoinTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKJoinTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKJoinTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKJoinTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKJoinTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKJoinTable::MergeFrom(const ACKJoinTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKJoinTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKJoinTable::CopyFrom(const ACKJoinTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKJoinTable::IsInitialized() const {

  return true;
}

void ACKJoinTable::Swap(ACKJoinTable* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKJoinTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKJoinTable_descriptor_;
  metadata.reflection = ACKJoinTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateTableStatus::kTableIDFieldNumber;
const int UpdateTableStatus::kPlayersFieldNumber;
#endif  // !_MSC_VER

UpdateTableStatus::UpdateTableStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpdateTableStatus::InitAsDefaultInstance() {
}

UpdateTableStatus::UpdateTableStatus(const UpdateTableStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateTableStatus::SharedCtor() {
  _cached_size_ = 0;
  tableid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateTableStatus::~UpdateTableStatus() {
  SharedDtor();
}

void UpdateTableStatus::SharedDtor() {
  if (tableid_ != &::google::protobuf::internal::kEmptyString) {
    delete tableid_;
  }
  if (this != default_instance_) {
  }
}

void UpdateTableStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateTableStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateTableStatus_descriptor_;
}

const UpdateTableStatus& UpdateTableStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

UpdateTableStatus* UpdateTableStatus::default_instance_ = NULL;

UpdateTableStatus* UpdateTableStatus::New() const {
  return new UpdateTableStatus;
}

void UpdateTableStatus::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_tableid()) {
      if (tableid_ != &::google::protobuf::internal::kEmptyString) {
        tableid_->clear();
      }
    }
  }
  players_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateTableStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string tableID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tableid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->tableid().data(), this->tableid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_players;
        break;
      }

      // repeated .wzq.PlayerStatus players = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_players:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_players()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_players;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateTableStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string tableID = 1;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tableid().data(), this->tableid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->tableid(), output);
  }

  // repeated .wzq.PlayerStatus players = 2;
  for (int i = 0; i < this->players_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->players(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpdateTableStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string tableID = 1;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tableid().data(), this->tableid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->tableid(), target);
  }

  // repeated .wzq.PlayerStatus players = 2;
  for (int i = 0; i < this->players_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->players(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpdateTableStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string tableID = 1;
    if (has_tableid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tableid());
    }

  }
  // repeated .wzq.PlayerStatus players = 2;
  total_size += 1 * this->players_size();
  for (int i = 0; i < this->players_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->players(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateTableStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateTableStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateTableStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateTableStatus::MergeFrom(const UpdateTableStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  players_.MergeFrom(from.players_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tableid()) {
      set_tableid(from.tableid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateTableStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateTableStatus::CopyFrom(const UpdateTableStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateTableStatus::IsInitialized() const {

  return true;
}

void UpdateTableStatus::Swap(UpdateTableStatus* other) {
  if (other != this) {
    std::swap(tableid_, other->tableid_);
    players_.Swap(&other->players_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateTableStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateTableStatus_descriptor_;
  metadata.reflection = UpdateTableStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerStatus::kBaseInfoFieldNumber;
const int PlayerStatus::kStateFieldNumber;
const int PlayerStatus::kColorFieldNumber;
#endif  // !_MSC_VER

PlayerStatus::PlayerStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerStatus::InitAsDefaultInstance() {
  baseinfo_ = const_cast< ::UserRawData*>(&::UserRawData::default_instance());
}

PlayerStatus::PlayerStatus(const PlayerStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerStatus::SharedCtor() {
  _cached_size_ = 0;
  baseinfo_ = NULL;
  state_ = 0;
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerStatus::~PlayerStatus() {
  SharedDtor();
}

void PlayerStatus::SharedDtor() {
  if (this != default_instance_) {
    delete baseinfo_;
  }
}

void PlayerStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerStatus_descriptor_;
}

const PlayerStatus& PlayerStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

PlayerStatus* PlayerStatus::default_instance_ = NULL;

PlayerStatus* PlayerStatus::New() const {
  return new PlayerStatus;
}

void PlayerStatus::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_baseinfo()) {
      if (baseinfo_ != NULL) baseinfo_->::UserRawData::Clear();
    }
    state_ = 0;
    color_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .UserRawData baseInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baseinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // optional .wzq.GameState state = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::GameState_IsValid(value)) {
            set_state(static_cast< ::wzq::GameState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_color;
        break;
      }

      // optional .wzq.ChessColorType color = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::ChessColorType_IsValid(value)) {
            set_color(static_cast< ::wzq::ChessColorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .UserRawData baseInfo = 1;
  if (has_baseinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->baseinfo(), output);
  }

  // optional .wzq.GameState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  // optional .wzq.ChessColorType color = 3;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->color(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .UserRawData baseInfo = 1;
  if (has_baseinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->baseinfo(), target);
  }

  // optional .wzq.GameState state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }

  // optional .wzq.ChessColorType color = 3;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->color(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .UserRawData baseInfo = 1;
    if (has_baseinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baseinfo());
    }

    // optional .wzq.GameState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .wzq.ChessColorType color = 3;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerStatus::MergeFrom(const PlayerStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baseinfo()) {
      mutable_baseinfo()->::UserRawData::MergeFrom(from.baseinfo());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerStatus::CopyFrom(const PlayerStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerStatus::IsInitialized() const {

  return true;
}

void PlayerStatus::Swap(PlayerStatus* other) {
  if (other != this) {
    std::swap(baseinfo_, other->baseinfo_);
    std::swap(state_, other->state_);
    std::swap(color_, other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerStatus_descriptor_;
  metadata.reflection = PlayerStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

REQReadyGame::REQReadyGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQReadyGame::InitAsDefaultInstance() {
}

REQReadyGame::REQReadyGame(const REQReadyGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQReadyGame::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQReadyGame::~REQReadyGame() {
  SharedDtor();
}

void REQReadyGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQReadyGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQReadyGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQReadyGame_descriptor_;
}

const REQReadyGame& REQReadyGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQReadyGame* REQReadyGame::default_instance_ = NULL;

REQReadyGame* REQReadyGame::New() const {
  return new REQReadyGame;
}

void REQReadyGame::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQReadyGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void REQReadyGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQReadyGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQReadyGame::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQReadyGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQReadyGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQReadyGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQReadyGame::MergeFrom(const REQReadyGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQReadyGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQReadyGame::CopyFrom(const REQReadyGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQReadyGame::IsInitialized() const {

  return true;
}

void REQReadyGame::Swap(REQReadyGame* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQReadyGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQReadyGame_descriptor_;
  metadata.reflection = REQReadyGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKReadyGame::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKReadyGame::ACKReadyGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKReadyGame::InitAsDefaultInstance() {
}

ACKReadyGame::ACKReadyGame(const ACKReadyGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKReadyGame::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKReadyGame::~ACKReadyGame() {
  SharedDtor();
}

void ACKReadyGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKReadyGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKReadyGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKReadyGame_descriptor_;
}

const ACKReadyGame& ACKReadyGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKReadyGame* ACKReadyGame::default_instance_ = NULL;

ACKReadyGame* ACKReadyGame::New() const {
  return new ACKReadyGame;
}

void ACKReadyGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKReadyGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKReadyGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKReadyGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKReadyGame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKReadyGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKReadyGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKReadyGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKReadyGame::MergeFrom(const ACKReadyGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKReadyGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKReadyGame::CopyFrom(const ACKReadyGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKReadyGame::IsInitialized() const {

  return true;
}

void ACKReadyGame::Swap(ACKReadyGame* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKReadyGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKReadyGame_descriptor_;
  metadata.reflection = ACKReadyGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQStartMatch::kUserIDFieldNumber;
#endif  // !_MSC_VER

REQStartMatch::REQStartMatch()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQStartMatch::InitAsDefaultInstance() {
}

REQStartMatch::REQStartMatch(const REQStartMatch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQStartMatch::SharedCtor() {
  _cached_size_ = 0;
  userid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQStartMatch::~REQStartMatch() {
  SharedDtor();
}

void REQStartMatch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQStartMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQStartMatch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQStartMatch_descriptor_;
}

const REQStartMatch& REQStartMatch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQStartMatch* REQStartMatch::default_instance_ = NULL;

REQStartMatch* REQStartMatch::New() const {
  return new REQStartMatch;
}

void REQStartMatch::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQStartMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQStartMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQStartMatch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQStartMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQStartMatch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQStartMatch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQStartMatch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQStartMatch::MergeFrom(const REQStartMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQStartMatch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQStartMatch::CopyFrom(const REQStartMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQStartMatch::IsInitialized() const {

  return true;
}

void REQStartMatch::Swap(REQStartMatch* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQStartMatch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQStartMatch_descriptor_;
  metadata.reflection = REQStartMatch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQStartGame::kUserIDFieldNumber;
#endif  // !_MSC_VER

REQStartGame::REQStartGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQStartGame::InitAsDefaultInstance() {
}

REQStartGame::REQStartGame(const REQStartGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQStartGame::SharedCtor() {
  _cached_size_ = 0;
  userid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQStartGame::~REQStartGame() {
  SharedDtor();
}

void REQStartGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQStartGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQStartGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQStartGame_descriptor_;
}

const REQStartGame& REQStartGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQStartGame* REQStartGame::default_instance_ = NULL;

REQStartGame* REQStartGame::New() const {
  return new REQStartGame;
}

void REQStartGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQStartGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQStartGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQStartGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQStartGame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQStartGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQStartGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQStartGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQStartGame::MergeFrom(const REQStartGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQStartGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQStartGame::CopyFrom(const REQStartGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQStartGame::IsInitialized() const {

  return true;
}

void REQStartGame::Swap(REQStartGame* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQStartGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQStartGame_descriptor_;
  metadata.reflection = REQStartGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKStartGame::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKStartGame::ACKStartGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKStartGame::InitAsDefaultInstance() {
}

ACKStartGame::ACKStartGame(const ACKStartGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKStartGame::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKStartGame::~ACKStartGame() {
  SharedDtor();
}

void ACKStartGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKStartGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKStartGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKStartGame_descriptor_;
}

const ACKStartGame& ACKStartGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKStartGame* ACKStartGame::default_instance_ = NULL;

ACKStartGame* ACKStartGame::New() const {
  return new ACKStartGame;
}

void ACKStartGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKStartGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKStartGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKStartGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKStartGame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKStartGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKStartGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKStartGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKStartGame::MergeFrom(const ACKStartGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKStartGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKStartGame::CopyFrom(const ACKStartGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKStartGame::IsInitialized() const {

  return true;
}

void ACKStartGame::Swap(ACKStartGame* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKStartGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKStartGame_descriptor_;
  metadata.reflection = ACKStartGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKStartMatch::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKStartMatch::ACKStartMatch()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKStartMatch::InitAsDefaultInstance() {
}

ACKStartMatch::ACKStartMatch(const ACKStartMatch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKStartMatch::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKStartMatch::~ACKStartMatch() {
  SharedDtor();
}

void ACKStartMatch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKStartMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKStartMatch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKStartMatch_descriptor_;
}

const ACKStartMatch& ACKStartMatch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKStartMatch* ACKStartMatch::default_instance_ = NULL;

ACKStartMatch* ACKStartMatch::New() const {
  return new ACKStartMatch;
}

void ACKStartMatch::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKStartMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKStartMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKStartMatch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKStartMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKStartMatch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKStartMatch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKStartMatch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKStartMatch::MergeFrom(const ACKStartMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKStartMatch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKStartMatch::CopyFrom(const ACKStartMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKStartMatch::IsInitialized() const {

  return true;
}

void ACKStartMatch::Swap(ACKStartMatch* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKStartMatch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKStartMatch_descriptor_;
  metadata.reflection = ACKStartMatch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCreateTable::kPlayersFieldNumber;
#endif  // !_MSC_VER

NotifyCreateTable::NotifyCreateTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyCreateTable::InitAsDefaultInstance() {
}

NotifyCreateTable::NotifyCreateTable(const NotifyCreateTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCreateTable::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCreateTable::~NotifyCreateTable() {
  SharedDtor();
}

void NotifyCreateTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyCreateTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyCreateTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyCreateTable_descriptor_;
}

const NotifyCreateTable& NotifyCreateTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyCreateTable* NotifyCreateTable::default_instance_ = NULL;

NotifyCreateTable* NotifyCreateTable::New() const {
  return new NotifyCreateTable;
}

void NotifyCreateTable::Clear() {
  players_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyCreateTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 players = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_players:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 8, input, this->mutable_players())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_players())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_players;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCreateTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int64 players = 1;
  for (int i = 0; i < this->players_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      1, this->players(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyCreateTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int64 players = 1;
  for (int i = 0; i < this->players_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt64ToArray(1, this->players(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyCreateTable::ByteSize() const {
  int total_size = 0;

  // repeated int64 players = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->players_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->players(i));
    }
    total_size += 1 * this->players_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCreateTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyCreateTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyCreateTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyCreateTable::MergeFrom(const NotifyCreateTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  players_.MergeFrom(from.players_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyCreateTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyCreateTable::CopyFrom(const NotifyCreateTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCreateTable::IsInitialized() const {

  return true;
}

void NotifyCreateTable::Swap(NotifyCreateTable* other) {
  if (other != this) {
    players_.Swap(&other->players_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyCreateTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyCreateTable_descriptor_;
  metadata.reflection = NotifyCreateTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyStartGame::kUserId1FieldNumber;
const int NotifyStartGame::kUserId2FieldNumber;
#endif  // !_MSC_VER

NotifyStartGame::NotifyStartGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyStartGame::InitAsDefaultInstance() {
}

NotifyStartGame::NotifyStartGame(const NotifyStartGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyStartGame::SharedCtor() {
  _cached_size_ = 0;
  userid1_ = GOOGLE_LONGLONG(0);
  userid2_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyStartGame::~NotifyStartGame() {
  SharedDtor();
}

void NotifyStartGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyStartGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyStartGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyStartGame_descriptor_;
}

const NotifyStartGame& NotifyStartGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyStartGame* NotifyStartGame::default_instance_ = NULL;

NotifyStartGame* NotifyStartGame::New() const {
  return new NotifyStartGame;
}

void NotifyStartGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid1_ = GOOGLE_LONGLONG(0);
    userid2_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyStartGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 userId1 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid1_)));
          set_has_userid1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_userId2;
        break;
      }

      // required int64 userId2 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_userId2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid2_)));
          set_has_userid2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyStartGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 userId1 = 1;
  if (has_userid1()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid1(), output);
  }

  // required int64 userId2 = 2;
  if (has_userid2()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->userid2(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyStartGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 userId1 = 1;
  if (has_userid1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid1(), target);
  }

  // required int64 userId2 = 2;
  if (has_userid2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->userid2(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyStartGame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 userId1 = 1;
    if (has_userid1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid1());
    }

    // required int64 userId2 = 2;
    if (has_userid2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid2());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyStartGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyStartGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyStartGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyStartGame::MergeFrom(const NotifyStartGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid1()) {
      set_userid1(from.userid1());
    }
    if (from.has_userid2()) {
      set_userid2(from.userid2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyStartGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyStartGame::CopyFrom(const NotifyStartGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyStartGame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NotifyStartGame::Swap(NotifyStartGame* other) {
  if (other != this) {
    std::swap(userid1_, other->userid1_);
    std::swap(userid2_, other->userid2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyStartGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyStartGame_descriptor_;
  metadata.reflection = NotifyStartGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQDownChess::kUserIdFieldNumber;
const int REQDownChess::kPosXFieldNumber;
const int REQDownChess::kPosYFieldNumber;
#endif  // !_MSC_VER

REQDownChess::REQDownChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQDownChess::InitAsDefaultInstance() {
}

REQDownChess::REQDownChess(const REQDownChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQDownChess::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = GOOGLE_LONGLONG(0);
  posx_ = 0;
  posy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQDownChess::~REQDownChess() {
  SharedDtor();
}

void REQDownChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQDownChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQDownChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQDownChess_descriptor_;
}

const REQDownChess& REQDownChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQDownChess* REQDownChess::default_instance_ = NULL;

REQDownChess* REQDownChess::New() const {
  return new REQDownChess;
}

void REQDownChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = GOOGLE_LONGLONG(0);
    posx_ = 0;
    posy_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQDownChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_posX;
        break;
      }

      // optional int32 posX = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_posX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &posx_)));
          set_has_posx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_posY;
        break;
      }

      // optional int32 posY = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_posY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &posy_)));
          set_has_posy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQDownChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->user_id(), output);
  }

  // optional int32 posX = 2;
  if (has_posx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->posx(), output);
  }

  // optional int32 posY = 3;
  if (has_posy()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->posy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQDownChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->user_id(), target);
  }

  // optional int32 posX = 2;
  if (has_posx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->posx(), target);
  }

  // optional int32 posY = 3;
  if (has_posy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->posy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQDownChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->user_id());
    }

    // optional int32 posX = 2;
    if (has_posx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->posx());
    }

    // optional int32 posY = 3;
    if (has_posy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->posy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQDownChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQDownChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQDownChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQDownChess::MergeFrom(const REQDownChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_posx()) {
      set_posx(from.posx());
    }
    if (from.has_posy()) {
      set_posy(from.posy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQDownChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQDownChess::CopyFrom(const REQDownChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQDownChess::IsInitialized() const {

  return true;
}

void REQDownChess::Swap(REQDownChess* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(posx_, other->posx_);
    std::swap(posy_, other->posy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQDownChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQDownChess_descriptor_;
  metadata.reflection = REQDownChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKDownChess::kPosXFieldNumber;
const int ACKDownChess::kPosYFieldNumber;
const int ACKDownChess::kColorFieldNumber;
#endif  // !_MSC_VER

ACKDownChess::ACKDownChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKDownChess::InitAsDefaultInstance() {
}

ACKDownChess::ACKDownChess(const ACKDownChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKDownChess::SharedCtor() {
  _cached_size_ = 0;
  posx_ = 0;
  posy_ = 0;
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKDownChess::~ACKDownChess() {
  SharedDtor();
}

void ACKDownChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKDownChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKDownChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKDownChess_descriptor_;
}

const ACKDownChess& ACKDownChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKDownChess* ACKDownChess::default_instance_ = NULL;

ACKDownChess* ACKDownChess::New() const {
  return new ACKDownChess;
}

void ACKDownChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    posx_ = 0;
    posy_ = 0;
    color_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKDownChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 posX = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &posx_)));
          set_has_posx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_posY;
        break;
      }

      // optional int32 posY = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_posY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &posy_)));
          set_has_posy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_color;
        break;
      }

      // optional .wzq.ChessColorType color = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::ChessColorType_IsValid(value)) {
            set_color(static_cast< ::wzq::ChessColorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKDownChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 posX = 1;
  if (has_posx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->posx(), output);
  }

  // optional int32 posY = 2;
  if (has_posy()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->posy(), output);
  }

  // optional .wzq.ChessColorType color = 3;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->color(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKDownChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 posX = 1;
  if (has_posx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->posx(), target);
  }

  // optional int32 posY = 2;
  if (has_posy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->posy(), target);
  }

  // optional .wzq.ChessColorType color = 3;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->color(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKDownChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 posX = 1;
    if (has_posx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->posx());
    }

    // optional int32 posY = 2;
    if (has_posy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->posy());
    }

    // optional .wzq.ChessColorType color = 3;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKDownChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKDownChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKDownChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKDownChess::MergeFrom(const ACKDownChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_posx()) {
      set_posx(from.posx());
    }
    if (from.has_posy()) {
      set_posy(from.posy());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKDownChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKDownChess::CopyFrom(const ACKDownChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKDownChess::IsInitialized() const {

  return true;
}

void ACKDownChess::Swap(ACKDownChess* other) {
  if (other != this) {
    std::swap(posx_, other->posx_);
    std::swap(posy_, other->posy_);
    std::swap(color_, other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKDownChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKDownChess_descriptor_;
  metadata.reflection = ACKDownChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQMatch::kUserIDFieldNumber;
const int REQMatch::kRoomTypeFieldNumber;
#endif  // !_MSC_VER

REQMatch::REQMatch()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQMatch::InitAsDefaultInstance() {
}

REQMatch::REQMatch(const REQMatch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQMatch::SharedCtor() {
  _cached_size_ = 0;
  userid_ = GOOGLE_LONGLONG(0);
  roomtype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQMatch::~REQMatch() {
  SharedDtor();
}

void REQMatch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQMatch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQMatch_descriptor_;
}

const REQMatch& REQMatch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQMatch* REQMatch::default_instance_ = NULL;

REQMatch* REQMatch::New() const {
  return new REQMatch;
}

void REQMatch::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid_ = GOOGLE_LONGLONG(0);
    roomtype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_roomType;
        break;
      }

      // required int32 roomType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roomType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &roomtype_)));
          set_has_roomtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid(), output);
  }

  // required int32 roomType = 2;
  if (has_roomtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->roomtype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQMatch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 userID = 1;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid(), target);
  }

  // required int32 roomType = 2;
  if (has_roomtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->roomtype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid());
    }

    // required int32 roomType = 2;
    if (has_roomtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->roomtype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQMatch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQMatch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQMatch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQMatch::MergeFrom(const REQMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_roomtype()) {
      set_roomtype(from.roomtype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQMatch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQMatch::CopyFrom(const REQMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void REQMatch::Swap(REQMatch* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(roomtype_, other->roomtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQMatch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQMatch_descriptor_;
  metadata.reflection = REQMatch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKMatch::kResultCodeFieldNumber;
const int ACKMatch::kEnemyUserInfoFieldNumber;
#endif  // !_MSC_VER

ACKMatch::ACKMatch()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKMatch::InitAsDefaultInstance() {
  enemyuserinfo_ = const_cast< ::UserRawData*>(&::UserRawData::default_instance());
}

ACKMatch::ACKMatch(const ACKMatch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKMatch::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  enemyuserinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKMatch::~ACKMatch() {
  SharedDtor();
}

void ACKMatch::SharedDtor() {
  if (this != default_instance_) {
    delete enemyuserinfo_;
  }
}

void ACKMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKMatch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKMatch_descriptor_;
}

const ACKMatch& ACKMatch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKMatch* ACKMatch::default_instance_ = NULL;

ACKMatch* ACKMatch::New() const {
  return new ACKMatch;
}

void ACKMatch::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
    if (has_enemyuserinfo()) {
      if (enemyuserinfo_ != NULL) enemyuserinfo_->::UserRawData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_enemyUserInfo;
        break;
      }

      // optional .UserRawData enemyUserInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_enemyUserInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_enemyuserinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  // optional .UserRawData enemyUserInfo = 2;
  if (has_enemyuserinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->enemyuserinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKMatch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  // optional .UserRawData enemyUserInfo = 2;
  if (has_enemyuserinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->enemyuserinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

    // optional .UserRawData enemyUserInfo = 2;
    if (has_enemyuserinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->enemyuserinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKMatch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKMatch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKMatch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKMatch::MergeFrom(const ACKMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
    if (from.has_enemyuserinfo()) {
      mutable_enemyuserinfo()->::UserRawData::MergeFrom(from.enemyuserinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKMatch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKMatch::CopyFrom(const ACKMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKMatch::IsInitialized() const {

  return true;
}

void ACKMatch::Swap(ACKMatch* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(enemyuserinfo_, other->enemyuserinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKMatch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKMatch_descriptor_;
  metadata.reflection = ACKMatch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCancelMatch::kUserIdFieldNumber;
const int NotifyCancelMatch::kRoomTypeFieldNumber;
#endif  // !_MSC_VER

NotifyCancelMatch::NotifyCancelMatch()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyCancelMatch::InitAsDefaultInstance() {
}

NotifyCancelMatch::NotifyCancelMatch(const NotifyCancelMatch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCancelMatch::SharedCtor() {
  _cached_size_ = 0;
  userid_ = GOOGLE_LONGLONG(0);
  roomtype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCancelMatch::~NotifyCancelMatch() {
  SharedDtor();
}

void NotifyCancelMatch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyCancelMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyCancelMatch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyCancelMatch_descriptor_;
}

const NotifyCancelMatch& NotifyCancelMatch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyCancelMatch* NotifyCancelMatch::default_instance_ = NULL;

NotifyCancelMatch* NotifyCancelMatch::New() const {
  return new NotifyCancelMatch;
}

void NotifyCancelMatch::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    userid_ = GOOGLE_LONGLONG(0);
    roomtype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyCancelMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_roomType;
        break;
      }

      // optional int32 roomType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roomType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &roomtype_)));
          set_has_roomtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCancelMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 userId = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userid(), output);
  }

  // optional int32 roomType = 2;
  if (has_roomtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->roomtype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyCancelMatch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 userId = 1;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->userid(), target);
  }

  // optional int32 roomType = 2;
  if (has_roomtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->roomtype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyCancelMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userId = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userid());
    }

    // optional int32 roomType = 2;
    if (has_roomtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->roomtype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCancelMatch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyCancelMatch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyCancelMatch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyCancelMatch::MergeFrom(const NotifyCancelMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_roomtype()) {
      set_roomtype(from.roomtype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyCancelMatch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyCancelMatch::CopyFrom(const NotifyCancelMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCancelMatch::IsInitialized() const {

  return true;
}

void NotifyCancelMatch::Swap(NotifyCancelMatch* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(roomtype_, other->roomtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyCancelMatch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyCancelMatch_descriptor_;
  metadata.reflection = NotifyCancelMatch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WinPosition_Row::kValuesFieldNumber;
#endif  // !_MSC_VER

WinPosition_Row::WinPosition_Row()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WinPosition_Row::InitAsDefaultInstance() {
}

WinPosition_Row::WinPosition_Row(const WinPosition_Row& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WinPosition_Row::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WinPosition_Row::~WinPosition_Row() {
  SharedDtor();
}

void WinPosition_Row::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WinPosition_Row::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WinPosition_Row::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WinPosition_Row_descriptor_;
}

const WinPosition_Row& WinPosition_Row::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

WinPosition_Row* WinPosition_Row::default_instance_ = NULL;

WinPosition_Row* WinPosition_Row::New() const {
  return new WinPosition_Row;
}

void WinPosition_Row::Clear() {
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WinPosition_Row::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 values = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_values:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_values())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_values())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_values;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WinPosition_Row::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->values(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WinPosition_Row::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int32 values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(1, this->values(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WinPosition_Row::ByteSize() const {
  int total_size = 0;

  // repeated int32 values = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->values_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->values(i));
    }
    total_size += 1 * this->values_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WinPosition_Row::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WinPosition_Row* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WinPosition_Row*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WinPosition_Row::MergeFrom(const WinPosition_Row& from) {
  GOOGLE_CHECK_NE(&from, this);
  values_.MergeFrom(from.values_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WinPosition_Row::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WinPosition_Row::CopyFrom(const WinPosition_Row& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WinPosition_Row::IsInitialized() const {

  return true;
}

void WinPosition_Row::Swap(WinPosition_Row* other) {
  if (other != this) {
    values_.Swap(&other->values_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WinPosition_Row::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WinPosition_Row_descriptor_;
  metadata.reflection = WinPosition_Row_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int WinPosition::kMatrixFieldNumber;
#endif  // !_MSC_VER

WinPosition::WinPosition()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WinPosition::InitAsDefaultInstance() {
}

WinPosition::WinPosition(const WinPosition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WinPosition::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WinPosition::~WinPosition() {
  SharedDtor();
}

void WinPosition::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WinPosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WinPosition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WinPosition_descriptor_;
}

const WinPosition& WinPosition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

WinPosition* WinPosition::default_instance_ = NULL;

WinPosition* WinPosition::New() const {
  return new WinPosition;
}

void WinPosition::Clear() {
  matrix_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WinPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .wzq.WinPosition.Row matrix = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_matrix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_matrix;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WinPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .wzq.WinPosition.Row matrix = 1;
  for (int i = 0; i < this->matrix_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->matrix(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WinPosition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .wzq.WinPosition.Row matrix = 1;
  for (int i = 0; i < this->matrix_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->matrix(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WinPosition::ByteSize() const {
  int total_size = 0;

  // repeated .wzq.WinPosition.Row matrix = 1;
  total_size += 1 * this->matrix_size();
  for (int i = 0; i < this->matrix_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->matrix(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WinPosition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WinPosition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WinPosition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WinPosition::MergeFrom(const WinPosition& from) {
  GOOGLE_CHECK_NE(&from, this);
  matrix_.MergeFrom(from.matrix_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WinPosition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WinPosition::CopyFrom(const WinPosition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WinPosition::IsInitialized() const {

  return true;
}

void WinPosition::Swap(WinPosition* other) {
  if (other != this) {
    matrix_.Swap(&other->matrix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WinPosition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WinPosition_descriptor_;
  metadata.reflection = WinPosition_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GameOver::kStateFieldNumber;
const int GameOver::kWinpositionFieldNumber;
#endif  // !_MSC_VER

GameOver::GameOver()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameOver::InitAsDefaultInstance() {
  winposition_ = const_cast< ::wzq::WinPosition*>(&::wzq::WinPosition::default_instance());
}

GameOver::GameOver(const GameOver& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameOver::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  winposition_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameOver::~GameOver() {
  SharedDtor();
}

void GameOver::SharedDtor() {
  if (this != default_instance_) {
    delete winposition_;
  }
}

void GameOver::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameOver::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameOver_descriptor_;
}

const GameOver& GameOver::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

GameOver* GameOver::default_instance_ = NULL;

GameOver* GameOver::New() const {
  return new GameOver;
}

void GameOver::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 0;
    if (has_winposition()) {
      if (winposition_ != NULL) winposition_->::wzq::WinPosition::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameOver::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .wzq.GameState state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::GameState_IsValid(value)) {
            set_state(static_cast< ::wzq::GameState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_winposition;
        break;
      }

      // optional .wzq.WinPosition winposition = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winposition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_winposition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameOver::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .wzq.GameState state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // optional .wzq.WinPosition winposition = 2;
  if (has_winposition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->winposition(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameOver::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .wzq.GameState state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // optional .wzq.WinPosition winposition = 2;
  if (has_winposition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->winposition(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameOver::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .wzq.GameState state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .wzq.WinPosition winposition = 2;
    if (has_winposition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->winposition());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameOver::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameOver* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameOver*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameOver::MergeFrom(const GameOver& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_winposition()) {
      mutable_winposition()->::wzq::WinPosition::MergeFrom(from.winposition());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameOver::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameOver::CopyFrom(const GameOver& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameOver::IsInitialized() const {

  return true;
}

void GameOver::Swap(GameOver* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(winposition_, other->winposition_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameOver::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameOver_descriptor_;
  metadata.reflection = GameOver_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyLocalGameStart::kChessColorFieldNumber;
#endif  // !_MSC_VER

NotifyLocalGameStart::NotifyLocalGameStart()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyLocalGameStart::InitAsDefaultInstance() {
}

NotifyLocalGameStart::NotifyLocalGameStart(const NotifyLocalGameStart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyLocalGameStart::SharedCtor() {
  _cached_size_ = 0;
  chesscolor_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyLocalGameStart::~NotifyLocalGameStart() {
  SharedDtor();
}

void NotifyLocalGameStart::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyLocalGameStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyLocalGameStart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyLocalGameStart_descriptor_;
}

const NotifyLocalGameStart& NotifyLocalGameStart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyLocalGameStart* NotifyLocalGameStart::default_instance_ = NULL;

NotifyLocalGameStart* NotifyLocalGameStart::New() const {
  return new NotifyLocalGameStart;
}

void NotifyLocalGameStart::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    chesscolor_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyLocalGameStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .wzq.ChessColorType chessColor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::ChessColorType_IsValid(value)) {
            set_chesscolor(static_cast< ::wzq::ChessColorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyLocalGameStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .wzq.ChessColorType chessColor = 1;
  if (has_chesscolor()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->chesscolor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyLocalGameStart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .wzq.ChessColorType chessColor = 1;
  if (has_chesscolor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->chesscolor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyLocalGameStart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .wzq.ChessColorType chessColor = 1;
    if (has_chesscolor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->chesscolor());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyLocalGameStart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyLocalGameStart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyLocalGameStart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyLocalGameStart::MergeFrom(const NotifyLocalGameStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chesscolor()) {
      set_chesscolor(from.chesscolor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyLocalGameStart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyLocalGameStart::CopyFrom(const NotifyLocalGameStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyLocalGameStart::IsInitialized() const {

  return true;
}

void NotifyLocalGameStart::Swap(NotifyLocalGameStart* other) {
  if (other != this) {
    std::swap(chesscolor_, other->chesscolor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyLocalGameStart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyLocalGameStart_descriptor_;
  metadata.reflection = NotifyLocalGameStart_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQRegretChess::kResultCodeFieldNumber;
#endif  // !_MSC_VER

REQRegretChess::REQRegretChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQRegretChess::InitAsDefaultInstance() {
}

REQRegretChess::REQRegretChess(const REQRegretChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQRegretChess::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQRegretChess::~REQRegretChess() {
  SharedDtor();
}

void REQRegretChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQRegretChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQRegretChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQRegretChess_descriptor_;
}

const REQRegretChess& REQRegretChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQRegretChess* REQRegretChess::default_instance_ = NULL;

REQRegretChess* REQRegretChess::New() const {
  return new REQRegretChess;
}

void REQRegretChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQRegretChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQRegretChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQRegretChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQRegretChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQRegretChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQRegretChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQRegretChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQRegretChess::MergeFrom(const REQRegretChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQRegretChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQRegretChess::CopyFrom(const REQRegretChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQRegretChess::IsInitialized() const {

  return true;
}

void REQRegretChess::Swap(REQRegretChess* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQRegretChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQRegretChess_descriptor_;
  metadata.reflection = REQRegretChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKRegretChess::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKRegretChess::ACKRegretChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKRegretChess::InitAsDefaultInstance() {
}

ACKRegretChess::ACKRegretChess(const ACKRegretChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKRegretChess::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKRegretChess::~ACKRegretChess() {
  SharedDtor();
}

void ACKRegretChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKRegretChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKRegretChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKRegretChess_descriptor_;
}

const ACKRegretChess& ACKRegretChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKRegretChess* ACKRegretChess::default_instance_ = NULL;

ACKRegretChess* ACKRegretChess::New() const {
  return new ACKRegretChess;
}

void ACKRegretChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKRegretChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKRegretChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKRegretChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKRegretChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKRegretChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKRegretChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKRegretChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKRegretChess::MergeFrom(const ACKRegretChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKRegretChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKRegretChess::CopyFrom(const ACKRegretChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKRegretChess::IsInitialized() const {

  return true;
}

void ACKRegretChess::Swap(ACKRegretChess* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKRegretChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKRegretChess_descriptor_;
  metadata.reflection = ACKRegretChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQAgreeRegretChess::kResultCodeFieldNumber;
#endif  // !_MSC_VER

REQAgreeRegretChess::REQAgreeRegretChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQAgreeRegretChess::InitAsDefaultInstance() {
}

REQAgreeRegretChess::REQAgreeRegretChess(const REQAgreeRegretChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQAgreeRegretChess::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQAgreeRegretChess::~REQAgreeRegretChess() {
  SharedDtor();
}

void REQAgreeRegretChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQAgreeRegretChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQAgreeRegretChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQAgreeRegretChess_descriptor_;
}

const REQAgreeRegretChess& REQAgreeRegretChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQAgreeRegretChess* REQAgreeRegretChess::default_instance_ = NULL;

REQAgreeRegretChess* REQAgreeRegretChess::New() const {
  return new REQAgreeRegretChess;
}

void REQAgreeRegretChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQAgreeRegretChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQAgreeRegretChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQAgreeRegretChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQAgreeRegretChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQAgreeRegretChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQAgreeRegretChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQAgreeRegretChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQAgreeRegretChess::MergeFrom(const REQAgreeRegretChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQAgreeRegretChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQAgreeRegretChess::CopyFrom(const REQAgreeRegretChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQAgreeRegretChess::IsInitialized() const {

  return true;
}

void REQAgreeRegretChess::Swap(REQAgreeRegretChess* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQAgreeRegretChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQAgreeRegretChess_descriptor_;
  metadata.reflection = REQAgreeRegretChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKAgreeRegretChess::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKAgreeRegretChess::ACKAgreeRegretChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKAgreeRegretChess::InitAsDefaultInstance() {
}

ACKAgreeRegretChess::ACKAgreeRegretChess(const ACKAgreeRegretChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKAgreeRegretChess::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKAgreeRegretChess::~ACKAgreeRegretChess() {
  SharedDtor();
}

void ACKAgreeRegretChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKAgreeRegretChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKAgreeRegretChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKAgreeRegretChess_descriptor_;
}

const ACKAgreeRegretChess& ACKAgreeRegretChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKAgreeRegretChess* ACKAgreeRegretChess::default_instance_ = NULL;

ACKAgreeRegretChess* ACKAgreeRegretChess::New() const {
  return new ACKAgreeRegretChess;
}

void ACKAgreeRegretChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKAgreeRegretChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKAgreeRegretChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKAgreeRegretChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKAgreeRegretChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKAgreeRegretChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKAgreeRegretChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKAgreeRegretChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKAgreeRegretChess::MergeFrom(const ACKAgreeRegretChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKAgreeRegretChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKAgreeRegretChess::CopyFrom(const ACKAgreeRegretChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKAgreeRegretChess::IsInitialized() const {

  return true;
}

void ACKAgreeRegretChess::Swap(ACKAgreeRegretChess* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKAgreeRegretChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKAgreeRegretChess_descriptor_;
  metadata.reflection = ACKAgreeRegretChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int REQDisAgreeRegretChess::kResultCodeFieldNumber;
#endif  // !_MSC_VER

REQDisAgreeRegretChess::REQDisAgreeRegretChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void REQDisAgreeRegretChess::InitAsDefaultInstance() {
}

REQDisAgreeRegretChess::REQDisAgreeRegretChess(const REQDisAgreeRegretChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void REQDisAgreeRegretChess::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

REQDisAgreeRegretChess::~REQDisAgreeRegretChess() {
  SharedDtor();
}

void REQDisAgreeRegretChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void REQDisAgreeRegretChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* REQDisAgreeRegretChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REQDisAgreeRegretChess_descriptor_;
}

const REQDisAgreeRegretChess& REQDisAgreeRegretChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

REQDisAgreeRegretChess* REQDisAgreeRegretChess::default_instance_ = NULL;

REQDisAgreeRegretChess* REQDisAgreeRegretChess::New() const {
  return new REQDisAgreeRegretChess;
}

void REQDisAgreeRegretChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool REQDisAgreeRegretChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void REQDisAgreeRegretChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* REQDisAgreeRegretChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int REQDisAgreeRegretChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void REQDisAgreeRegretChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const REQDisAgreeRegretChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const REQDisAgreeRegretChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void REQDisAgreeRegretChess::MergeFrom(const REQDisAgreeRegretChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void REQDisAgreeRegretChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void REQDisAgreeRegretChess::CopyFrom(const REQDisAgreeRegretChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool REQDisAgreeRegretChess::IsInitialized() const {

  return true;
}

void REQDisAgreeRegretChess::Swap(REQDisAgreeRegretChess* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata REQDisAgreeRegretChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = REQDisAgreeRegretChess_descriptor_;
  metadata.reflection = REQDisAgreeRegretChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACKDisAgreeRegretChess::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ACKDisAgreeRegretChess::ACKDisAgreeRegretChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKDisAgreeRegretChess::InitAsDefaultInstance() {
}

ACKDisAgreeRegretChess::ACKDisAgreeRegretChess(const ACKDisAgreeRegretChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKDisAgreeRegretChess::SharedCtor() {
  _cached_size_ = 0;
  resultcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKDisAgreeRegretChess::~ACKDisAgreeRegretChess() {
  SharedDtor();
}

void ACKDisAgreeRegretChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKDisAgreeRegretChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKDisAgreeRegretChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKDisAgreeRegretChess_descriptor_;
}

const ACKDisAgreeRegretChess& ACKDisAgreeRegretChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKDisAgreeRegretChess* ACKDisAgreeRegretChess::default_instance_ = NULL;

ACKDisAgreeRegretChess* ACKDisAgreeRegretChess::New() const {
  return new ACKDisAgreeRegretChess;
}

void ACKDisAgreeRegretChess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resultcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKDisAgreeRegretChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ACKDisAgreeRegretChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKDisAgreeRegretChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resultcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKDisAgreeRegretChess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKDisAgreeRegretChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKDisAgreeRegretChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKDisAgreeRegretChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKDisAgreeRegretChess::MergeFrom(const ACKDisAgreeRegretChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKDisAgreeRegretChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKDisAgreeRegretChess::CopyFrom(const ACKDisAgreeRegretChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKDisAgreeRegretChess::IsInitialized() const {

  return true;
}

void ACKDisAgreeRegretChess::Swap(ACKDisAgreeRegretChess* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKDisAgreeRegretChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKDisAgreeRegretChess_descriptor_;
  metadata.reflection = ACKDisAgreeRegretChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyGiveUp::NotifyGiveUp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyGiveUp::InitAsDefaultInstance() {
}

NotifyGiveUp::NotifyGiveUp(const NotifyGiveUp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyGiveUp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyGiveUp::~NotifyGiveUp() {
  SharedDtor();
}

void NotifyGiveUp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyGiveUp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyGiveUp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyGiveUp_descriptor_;
}

const NotifyGiveUp& NotifyGiveUp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyGiveUp* NotifyGiveUp::default_instance_ = NULL;

NotifyGiveUp* NotifyGiveUp::New() const {
  return new NotifyGiveUp;
}

void NotifyGiveUp::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyGiveUp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NotifyGiveUp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyGiveUp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyGiveUp::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyGiveUp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyGiveUp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyGiveUp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyGiveUp::MergeFrom(const NotifyGiveUp& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyGiveUp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyGiveUp::CopyFrom(const NotifyGiveUp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyGiveUp::IsInitialized() const {

  return true;
}

void NotifyGiveUp::Swap(NotifyGiveUp* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyGiveUp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyGiveUp_descriptor_;
  metadata.reflection = NotifyGiveUp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyPeaceChess::NotifyPeaceChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyPeaceChess::InitAsDefaultInstance() {
}

NotifyPeaceChess::NotifyPeaceChess(const NotifyPeaceChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyPeaceChess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyPeaceChess::~NotifyPeaceChess() {
  SharedDtor();
}

void NotifyPeaceChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyPeaceChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyPeaceChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyPeaceChess_descriptor_;
}

const NotifyPeaceChess& NotifyPeaceChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyPeaceChess* NotifyPeaceChess::default_instance_ = NULL;

NotifyPeaceChess* NotifyPeaceChess::New() const {
  return new NotifyPeaceChess;
}

void NotifyPeaceChess::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyPeaceChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NotifyPeaceChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyPeaceChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyPeaceChess::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyPeaceChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyPeaceChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyPeaceChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyPeaceChess::MergeFrom(const NotifyPeaceChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyPeaceChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyPeaceChess::CopyFrom(const NotifyPeaceChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyPeaceChess::IsInitialized() const {

  return true;
}

void NotifyPeaceChess::Swap(NotifyPeaceChess* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyPeaceChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyPeaceChess_descriptor_;
  metadata.reflection = NotifyPeaceChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyASKPeaceChess::NotifyASKPeaceChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyASKPeaceChess::InitAsDefaultInstance() {
}

NotifyASKPeaceChess::NotifyASKPeaceChess(const NotifyASKPeaceChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyASKPeaceChess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyASKPeaceChess::~NotifyASKPeaceChess() {
  SharedDtor();
}

void NotifyASKPeaceChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyASKPeaceChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyASKPeaceChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyASKPeaceChess_descriptor_;
}

const NotifyASKPeaceChess& NotifyASKPeaceChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyASKPeaceChess* NotifyASKPeaceChess::default_instance_ = NULL;

NotifyASKPeaceChess* NotifyASKPeaceChess::New() const {
  return new NotifyASKPeaceChess;
}

void NotifyASKPeaceChess::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyASKPeaceChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NotifyASKPeaceChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyASKPeaceChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyASKPeaceChess::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyASKPeaceChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyASKPeaceChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyASKPeaceChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyASKPeaceChess::MergeFrom(const NotifyASKPeaceChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyASKPeaceChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyASKPeaceChess::CopyFrom(const NotifyASKPeaceChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyASKPeaceChess::IsInitialized() const {

  return true;
}

void NotifyASKPeaceChess::Swap(NotifyASKPeaceChess* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyASKPeaceChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyASKPeaceChess_descriptor_;
  metadata.reflection = NotifyASKPeaceChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyAgreePeaceChess::NotifyAgreePeaceChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyAgreePeaceChess::InitAsDefaultInstance() {
}

NotifyAgreePeaceChess::NotifyAgreePeaceChess(const NotifyAgreePeaceChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyAgreePeaceChess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyAgreePeaceChess::~NotifyAgreePeaceChess() {
  SharedDtor();
}

void NotifyAgreePeaceChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyAgreePeaceChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyAgreePeaceChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyAgreePeaceChess_descriptor_;
}

const NotifyAgreePeaceChess& NotifyAgreePeaceChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyAgreePeaceChess* NotifyAgreePeaceChess::default_instance_ = NULL;

NotifyAgreePeaceChess* NotifyAgreePeaceChess::New() const {
  return new NotifyAgreePeaceChess;
}

void NotifyAgreePeaceChess::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyAgreePeaceChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NotifyAgreePeaceChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyAgreePeaceChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyAgreePeaceChess::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyAgreePeaceChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyAgreePeaceChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyAgreePeaceChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyAgreePeaceChess::MergeFrom(const NotifyAgreePeaceChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyAgreePeaceChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyAgreePeaceChess::CopyFrom(const NotifyAgreePeaceChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyAgreePeaceChess::IsInitialized() const {

  return true;
}

void NotifyAgreePeaceChess::Swap(NotifyAgreePeaceChess* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyAgreePeaceChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyAgreePeaceChess_descriptor_;
  metadata.reflection = NotifyAgreePeaceChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyDisagreePeaceChess::NotifyDisagreePeaceChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NotifyDisagreePeaceChess::InitAsDefaultInstance() {
}

NotifyDisagreePeaceChess::NotifyDisagreePeaceChess(const NotifyDisagreePeaceChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyDisagreePeaceChess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyDisagreePeaceChess::~NotifyDisagreePeaceChess() {
  SharedDtor();
}

void NotifyDisagreePeaceChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NotifyDisagreePeaceChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyDisagreePeaceChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotifyDisagreePeaceChess_descriptor_;
}

const NotifyDisagreePeaceChess& NotifyDisagreePeaceChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

NotifyDisagreePeaceChess* NotifyDisagreePeaceChess::default_instance_ = NULL;

NotifyDisagreePeaceChess* NotifyDisagreePeaceChess::New() const {
  return new NotifyDisagreePeaceChess;
}

void NotifyDisagreePeaceChess::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NotifyDisagreePeaceChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NotifyDisagreePeaceChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NotifyDisagreePeaceChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NotifyDisagreePeaceChess::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyDisagreePeaceChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NotifyDisagreePeaceChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NotifyDisagreePeaceChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotifyDisagreePeaceChess::MergeFrom(const NotifyDisagreePeaceChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NotifyDisagreePeaceChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyDisagreePeaceChess::CopyFrom(const NotifyDisagreePeaceChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyDisagreePeaceChess::IsInitialized() const {

  return true;
}

void NotifyDisagreePeaceChess::Swap(NotifyDisagreePeaceChess* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NotifyDisagreePeaceChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotifyDisagreePeaceChess_descriptor_;
  metadata.reflection = NotifyDisagreePeaceChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ACKAgreePeaceChess::ACKAgreePeaceChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKAgreePeaceChess::InitAsDefaultInstance() {
}

ACKAgreePeaceChess::ACKAgreePeaceChess(const ACKAgreePeaceChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKAgreePeaceChess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKAgreePeaceChess::~ACKAgreePeaceChess() {
  SharedDtor();
}

void ACKAgreePeaceChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKAgreePeaceChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKAgreePeaceChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKAgreePeaceChess_descriptor_;
}

const ACKAgreePeaceChess& ACKAgreePeaceChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKAgreePeaceChess* ACKAgreePeaceChess::default_instance_ = NULL;

ACKAgreePeaceChess* ACKAgreePeaceChess::New() const {
  return new ACKAgreePeaceChess;
}

void ACKAgreePeaceChess::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKAgreePeaceChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ACKAgreePeaceChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKAgreePeaceChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKAgreePeaceChess::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKAgreePeaceChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKAgreePeaceChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKAgreePeaceChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKAgreePeaceChess::MergeFrom(const ACKAgreePeaceChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKAgreePeaceChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKAgreePeaceChess::CopyFrom(const ACKAgreePeaceChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKAgreePeaceChess::IsInitialized() const {

  return true;
}

void ACKAgreePeaceChess::Swap(ACKAgreePeaceChess* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKAgreePeaceChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKAgreePeaceChess_descriptor_;
  metadata.reflection = ACKAgreePeaceChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ACKDisagreePeaceChess::ACKDisagreePeaceChess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ACKDisagreePeaceChess::InitAsDefaultInstance() {
}

ACKDisagreePeaceChess::ACKDisagreePeaceChess(const ACKDisagreePeaceChess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ACKDisagreePeaceChess::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACKDisagreePeaceChess::~ACKDisagreePeaceChess() {
  SharedDtor();
}

void ACKDisagreePeaceChess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACKDisagreePeaceChess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACKDisagreePeaceChess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACKDisagreePeaceChess_descriptor_;
}

const ACKDisagreePeaceChess& ACKDisagreePeaceChess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ACKDisagreePeaceChess* ACKDisagreePeaceChess::default_instance_ = NULL;

ACKDisagreePeaceChess* ACKDisagreePeaceChess::New() const {
  return new ACKDisagreePeaceChess;
}

void ACKDisagreePeaceChess::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACKDisagreePeaceChess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ACKDisagreePeaceChess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ACKDisagreePeaceChess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ACKDisagreePeaceChess::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACKDisagreePeaceChess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACKDisagreePeaceChess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACKDisagreePeaceChess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACKDisagreePeaceChess::MergeFrom(const ACKDisagreePeaceChess& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACKDisagreePeaceChess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACKDisagreePeaceChess::CopyFrom(const ACKDisagreePeaceChess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACKDisagreePeaceChess::IsInitialized() const {

  return true;
}

void ACKDisagreePeaceChess::Swap(ACKDisagreePeaceChess* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACKDisagreePeaceChess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACKDisagreePeaceChess_descriptor_;
  metadata.reflection = ACKDisagreePeaceChess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChessMove::kXFieldNumber;
const int ChessMove::kYFieldNumber;
#endif  // !_MSC_VER

ChessMove::ChessMove()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChessMove::InitAsDefaultInstance() {
}

ChessMove::ChessMove(const ChessMove& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChessMove::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChessMove::~ChessMove() {
  SharedDtor();
}

void ChessMove::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChessMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChessMove::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChessMove_descriptor_;
}

const ChessMove& ChessMove::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

ChessMove* ChessMove::default_instance_ = NULL;

ChessMove* ChessMove::New() const {
  return new ChessMove;
}

void ChessMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChessMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChessMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChessMove::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // optional int32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChessMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChessMove::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChessMove* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChessMove*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChessMove::MergeFrom(const ChessMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChessMove::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChessMove::CopyFrom(const ChessMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChessMove::IsInitialized() const {

  return true;
}

void ChessMove::Swap(ChessMove* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChessMove::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChessMove_descriptor_;
  metadata.reflection = ChessMove_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayingResult::kGameresultFieldNumber;
const int PlayingResult::kWinuserIDFieldNumber;
const int PlayingResult::kLoseuserIDFieldNumber;
const int PlayingResult::kColorFieldNumber;
const int PlayingResult::kMovesFieldNumber;
#endif  // !_MSC_VER

PlayingResult::PlayingResult()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayingResult::InitAsDefaultInstance() {
}

PlayingResult::PlayingResult(const PlayingResult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayingResult::SharedCtor() {
  _cached_size_ = 0;
  gameresult_ = 0;
  winuserid_ = GOOGLE_LONGLONG(0);
  loseuserid_ = GOOGLE_LONGLONG(0);
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayingResult::~PlayingResult() {
  SharedDtor();
}

void PlayingResult::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PlayingResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayingResult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayingResult_descriptor_;
}

const PlayingResult& PlayingResult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_wzqGame_2eproto();
  return *default_instance_;
}

PlayingResult* PlayingResult::default_instance_ = NULL;

PlayingResult* PlayingResult::New() const {
  return new PlayingResult;
}

void PlayingResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameresult_ = 0;
    winuserid_ = GOOGLE_LONGLONG(0);
    loseuserid_ = GOOGLE_LONGLONG(0);
    color_ = 0;
  }
  moves_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayingResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .wzq.GameState gameresult = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::GameState_IsValid(value)) {
            set_gameresult(static_cast< ::wzq::GameState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_winuserID;
        break;
      }

      // optional int64 winuserID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_winuserID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &winuserid_)));
          set_has_winuserid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_loseuserID;
        break;
      }

      // optional int64 loseuserID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_loseuserID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &loseuserid_)));
          set_has_loseuserid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_color;
        break;
      }

      // optional .wzq.ChessColorType color = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wzq::ChessColorType_IsValid(value)) {
            set_color(static_cast< ::wzq::ChessColorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_moves;
        break;
      }

      // repeated .wzq.ChessMove moves = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_moves:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_moves()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_moves;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayingResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .wzq.GameState gameresult = 1;
  if (has_gameresult()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->gameresult(), output);
  }

  // optional int64 winuserID = 2;
  if (has_winuserid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->winuserid(), output);
  }

  // optional int64 loseuserID = 3;
  if (has_loseuserid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->loseuserid(), output);
  }

  // optional .wzq.ChessColorType color = 4;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->color(), output);
  }

  // repeated .wzq.ChessMove moves = 5;
  for (int i = 0; i < this->moves_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->moves(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayingResult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .wzq.GameState gameresult = 1;
  if (has_gameresult()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->gameresult(), target);
  }

  // optional int64 winuserID = 2;
  if (has_winuserid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->winuserid(), target);
  }

  // optional int64 loseuserID = 3;
  if (has_loseuserid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->loseuserid(), target);
  }

  // optional .wzq.ChessColorType color = 4;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->color(), target);
  }

  // repeated .wzq.ChessMove moves = 5;
  for (int i = 0; i < this->moves_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->moves(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayingResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .wzq.GameState gameresult = 1;
    if (has_gameresult()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->gameresult());
    }

    // optional int64 winuserID = 2;
    if (has_winuserid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->winuserid());
    }

    // optional int64 loseuserID = 3;
    if (has_loseuserid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->loseuserid());
    }

    // optional .wzq.ChessColorType color = 4;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

  }
  // repeated .wzq.ChessMove moves = 5;
  total_size += 1 * this->moves_size();
  for (int i = 0; i < this->moves_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->moves(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayingResult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayingResult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayingResult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayingResult::MergeFrom(const PlayingResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  moves_.MergeFrom(from.moves_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameresult()) {
      set_gameresult(from.gameresult());
    }
    if (from.has_winuserid()) {
      set_winuserid(from.winuserid());
    }
    if (from.has_loseuserid()) {
      set_loseuserid(from.loseuserid());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayingResult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayingResult::CopyFrom(const PlayingResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayingResult::IsInitialized() const {

  return true;
}

void PlayingResult::Swap(PlayingResult* other) {
  if (other != this) {
    std::swap(gameresult_, other->gameresult_);
    std::swap(winuserid_, other->winuserid_);
    std::swap(loseuserid_, other->loseuserid_);
    std::swap(color_, other->color_);
    moves_.Swap(&other->moves_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayingResult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayingResult_descriptor_;
  metadata.reflection = PlayingResult_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wzq

// @@protoc_insertion_point(global_scope)
